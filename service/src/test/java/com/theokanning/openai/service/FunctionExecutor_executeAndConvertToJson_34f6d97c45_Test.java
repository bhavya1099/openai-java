// ********RoostGPT********
/*
Test generated by RoostGPT for test java-junit4-test using AI Type Open AI and AI Model gpt-4

Test Scenario 1:
- Description: Test when the execution returns a TextNode object and the converted JsonNode is not missing.
- Steps: Pass a ChatFunctionCall object where the execution returns a valid TextNode object.
- Expected Output: The returned JsonNode object should match the contents of the TextNode object.

Test Scenario 2:
- Description: Test when the execution returns a TextNode object and the converted JsonNode is missing.
- Steps: Pass a ChatFunctionCall object where the execution returns a TextNode object that converts to a missing JsonNode.
- Expected Output: The returned object should be the original TextNode object.

Test Scenario 3:
- Description: Test when the execution returns an ObjectNode object.
- Steps: Pass a ChatFunctionCall object where the execution returns a valid ObjectNode object.
- Expected Output: The returned object should be the original ObjectNode object.

Test Scenario 4:
- Description: Test when the execution returns a String object that can be parsed into a valid JsonNode.
- Steps: Pass a ChatFunctionCall object where the execution returns a valid JSON String.
- Expected Output: The returned JsonNode object should match the contents of the parsed String object.

Test Scenario 5:
- Description: Test when the execution returns a String object that cannot be parsed into a JsonNode.
- Steps: Pass a ChatFunctionCall object where the execution returns a String that is not valid JSON.
- Expected Output: A RuntimeException should be thrown with a message indicating a parsing exception.

Test Scenario 6:
- Description: Test when the execution returns an object that is not a TextNode, ObjectNode, or String.
- Steps: Pass a ChatFunctionCall object where the execution returns an object of any other type.
- Expected Output: The returned JsonNode object should match the contents of the object after it has been converted to a string and parsed into a JsonNode.

Test Scenario 7:
- Description: Test when the execution throws an exception.
- Steps: Pass a ChatFunctionCall object where the execution throws an exception.
- Expected Output: A RuntimeException should be thrown with the original exception as its cause.
*/

// ********RoostGPT********
package com.theokanning.openai.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.TextNode;
import com.theokanning.openai.completion.chat.ChatFunctionCall;
import com.theokanning.openai.function.FunctionExecutor;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

public class FunctionExecutor_executeAndConvertToJson_34f6d97c45_Test {

    private FunctionExecutor functionExecutor;
    private ChatFunctionCall chatFunctionCall;

    @Before
    public void setup() {
        functionExecutor = Mockito.spy(new FunctionExecutor());
        chatFunctionCall = Mockito.mock(ChatFunctionCall.class);
    }

    @Test
    public void testExecuteAndConvertToJson_TextNode_NotMissing() throws Exception {
        TextNode textNode = new TextNode("{\"key\": \"value\"}");
        when(functionExecutor.execute(chatFunctionCall)).thenReturn(textNode);

        JsonNode result = functionExecutor.executeAndConvertToJson(chatFunctionCall);

        assertEquals("value", result.get("key").asText());
    }

    @Test
    public void testExecuteAndConvertToJson_TextNode_Missing() throws Exception {
        TextNode textNode = new TextNode("");
        when(functionExecutor.execute(chatFunctionCall)).thenReturn(textNode);

        JsonNode result = functionExecutor.executeAndConvertToJson(chatFunctionCall);

        assertTrue(result.isMissingNode());
    }

    @Test
    public void testExecuteAndConvertToJson_ObjectNode() throws Exception {
        ObjectNode objectNode = functionExecutor.getMAPPER().createObjectNode().put("key", "value");
        when(functionExecutor.execute(chatFunctionCall)).thenReturn(objectNode);

        JsonNode result = functionExecutor.executeAndConvertToJson(chatFunctionCall);

        assertEquals("value", result.get("key").asText());
    }

    @Test
    public void testExecuteAndConvertToJson_String_Valid() throws Exception {
        String jsonString = "{\"key\": \"value\"}";
        when(functionExecutor.execute(chatFunctionCall)).thenReturn(jsonString);

        JsonNode result = functionExecutor.executeAndConvertToJson(chatFunctionCall);

        assertEquals("value", result.get("key").asText());
    }

    @Test(expected = RuntimeException.class)
    public void testExecuteAndConvertToJson_String_Invalid() throws Exception {
        String jsonString = "invalid json";
        when(functionExecutor.execute(chatFunctionCall)).thenReturn(jsonString);

        functionExecutor.executeAndConvertToJson(chatFunctionCall);
    }

    @Test
    public void testExecuteAndConvertToJson_OtherObject() throws Exception {
        Object object = new Object() {
            public String key = "value";
        };
        when(functionExecutor.execute(chatFunctionCall)).thenReturn(object);

        JsonNode result = functionExecutor.executeAndConvertToJson(chatFunctionCall);

        assertEquals("value", result.get("key").asText());
    }

    @Test(expected = RuntimeException.class)
    public void testExecuteAndConvertToJson_ExecutionThrowsException() throws Exception {
        when(functionExecutor.execute(chatFunctionCall)).thenThrow(new RuntimeException());

        functionExecutor.executeAndConvertToJson(chatFunctionCall);
    }
}
