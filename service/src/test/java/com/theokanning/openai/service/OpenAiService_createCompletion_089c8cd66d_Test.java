// ********RoostGPT********
/*
Test generated by RoostGPT for test java-junit4-test using AI Type Open AI and AI Model gpt-4

1. Scenario: Test for successful completion creation
   - Given a valid CompletionRequest object
   - When the createCompletion function is called with the valid request
   - Then ensure the function returns a valid CompletionResult object

2. Scenario: Test for handling of invalid CompletionRequest
   - Given an invalid CompletionRequest object (e.g., missing required fields)
   - When the createCompletion function is called with the invalid request
   - Then ensure the function throws an appropriate exception or returns an error

3. Scenario: Test for handling of null CompletionRequest
   - Given a null CompletionRequest
   - When the createCompletion function is called with null
   - Then ensure the function throws a NullPointerException

4. Scenario: Test for API failure
   - Given a valid CompletionRequest object
   - But the underlying API service is down or not responding
   - When the createCompletion function is called with the valid request
   - Then ensure the function handles the failure gracefully, either by throwing an exception, returning an error, or retrying the request

5. Scenario: Test for handling of API errors
   - Given a valid CompletionRequest object
   - But the underlying API returns an error (e.g., due to rate limiting, internal server error, etc.)
   - When the createCompletion function is called with the valid request
   - Then ensure the function handles the error appropriately, either by throwing an exception, returning an error, or retrying the request

6. Scenario: Test for handling of timeout
   - Given a valid CompletionRequest object
   - But the underlying API takes too long to respond
   - When the createCompletion function is called with the valid request
   - Then ensure the function handles the timeout gracefully, either by throwing an exception, returning an error, or retrying the request

7. Scenario: Test for thread safety
   - Given multiple threads each with a valid CompletionRequest object
   - When the createCompletion function is called concurrently from these threads
   - Then ensure the function handles the concurrent calls correctly and returns the correct results for each thread

8. Scenario: Test for handling of large CompletionRequest objects
   - Given a valid but large CompletionRequest object (e.g., with a large amount of data)
   - When the createCompletion function is called with this large request
   - Then ensure the function handles the large request correctly and returns a valid CompletionResult

*/

// ********RoostGPT********
package com.theokanning.openai.service;

import com.theokanning.openai.completion.CompletionRequest;
import com.theokanning.openai.completion.CompletionResult;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

public class OpenAiService_createCompletion_089c8cd66d_Test {

    @InjectMocks
    private OpenAiService openAiService;

    @Mock
    private OpenAiApi api;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testCreateCompletion_Success() {
        CompletionRequest request = new CompletionRequest();
        CompletionResult expected = new CompletionResult();
        when(api.createCompletion(request)).thenReturn(Single.just(expected));
        CompletionResult actual = openAiService.createCompletion(request);
        assertEquals(expected, actual);
    }

    @Test(expected = NullPointerException.class)
    public void testCreateCompletion_NullRequest() {
        openAiService.createCompletion(null);
    }

    @Test(expected = RuntimeException.class)
    public void testCreateCompletion_ApiFailure() {
        CompletionRequest request = new CompletionRequest();
        when(api.createCompletion(request)).thenThrow(new RuntimeException());
        openAiService.createCompletion(request);
    }
}
