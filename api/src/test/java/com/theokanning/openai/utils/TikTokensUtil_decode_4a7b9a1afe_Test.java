// ********RoostGPT********
/*
Test generated by RoostGPT for test java-junit4-test using AI Type Open AI and AI Model gpt-4

1. **Scenario**: Verify the `decode` function with valid `Encoding` and `encoded` list
    - **Given**: A valid `Encoding` object and a valid list of integers as `encoded` list
    - **When**: The `decode` function is invoked
    - **Then**: Ensure the function returns a decoded string

2. **Scenario**: Verify the `decode` function with null `Encoding`
    - **Given**: A null `Encoding` object and a valid list of integers as `encoded` list
    - **When**: The `decode` function is invoked
    - **Then**: Expect an exception (NullPointerException)

3. **Scenario**: Verify the `decode` function with null `encoded` list
    - **Given**: A valid `Encoding` object and null `encoded` list
    - **When**: The `decode` function is invoked
    - **Then**: Expect an exception (NullPointerException)

4. **Scenario**: Verify the `decode` function with both `Encoding` and `encoded` list as null
    - **Given**: A null `Encoding` object and null `encoded` list
    - **When**: The `decode` function is invoked
    - **Then**: Expect an exception (NullPointerException)

5. **Scenario**: Verify the `decode` function with an empty `encoded` list
    - **Given**: A valid `Encoding` object and an empty `encoded` list
    - **When**: The `decode` function is invoked
    - **Then**: Ensure the function returns an empty string or throws an exception based on the implementation of the `decode` method in the `Encoding` object

6. **Scenario**: Verify the `decode` function with `encoded` list containing negative integers
    - **Given**: A valid `Encoding` object and `encoded` list containing negative integers
    - **When**: The `decode` function is invoked
    - **Then**: Ensure the function returns a decoded string or throws an exception based on the implementation of the `decode` method in the `Encoding` object

7. **Scenario**: Verify the `decode` function with `encoded` list containing integers not in the range of the `Encoding` object
    - **Given**: A valid `Encoding` object and `encoded` list containing integers not in the range of the `Encoding` object
    - **When**: The `decode` function is invoked
    - **Then**: Expect an exception or a specific output based on the implementation of the `decode` method in the `Encoding` object

8. **Scenario**: Verify the `decode` function with a large `encoded` list
    - **Given**: A valid `Encoding` object and a large `encoded` list
    - **When**: The `decode` function is invoked
    - **Then**: Ensure the function handles the list correctly and returns the appropriate decoded string

Please note that the expected behavior in some of these scenarios depends on the implementation of the `decode` method in the `Encoding` object.
*/

// ********RoostGPT********
package com.theokanning.openai.utils;

import com.knuddels.jtokkit.Encodings;
import com.knuddels.jtokkit.api.Encoding;
import com.knuddels.jtokkit.api.EncodingRegistry;
import com.knuddels.jtokkit.api.EncodingType;
import com.knuddels.jtokkit.api.ModelType;
import com.theokanning.openai.completion.chat.ChatMessage;
import lombok.AllArgsConstructor;
import lombok.Getter;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.*;

public class TikTokensUtil_decode_4a7b9a1afe_Test {

    @Test
    public void testDecodeWithValidEncodingAndEncodedList() {
        Encoding enc = Encodings.newDefaultEncoding();
        List<Integer> encoded = Arrays.asList(72, 101, 108, 108, 111);
        
        String result = TikTokensUtil.decode(enc, encoded);

        Assertions.assertEquals("Hello", result);
    }
    
    @Test
    public void testDecodeWithNullEncoding() {
        Encoding enc = null;
        List<Integer> encoded = Arrays.asList(72, 101, 108, 108, 111);
        
        Assertions.assertThrows(NullPointerException.class, () -> TikTokensUtil.decode(enc, encoded));
    }
    
    @Test
    public void testDecodeWithNullEncodedList() {
        Encoding enc = Encodings.newDefaultEncoding();
        List<Integer> encoded = null;
        
        Assertions.assertThrows(NullPointerException.class, () -> TikTokensUtil.decode(enc, encoded));
    }

    @Test
    public void testDecodeWithNullEncodingAndEncodedList() {
        Encoding enc = null;
        List<Integer> encoded = null;
        
        Assertions.assertThrows(NullPointerException.class, () -> TikTokensUtil.decode(enc, encoded));
    }

    @Test
    public void testDecodeWithEmptyEncodedList() {
        Encoding enc = Encodings.newDefaultEncoding();
        List<Integer> encoded = new ArrayList<>();
        
        String result = TikTokensUtil.decode(enc, encoded);

        Assertions.assertEquals("", result);
    }

    @Test
    public void testDecodeWithNegativeIntegersInEncodedList() {
        Encoding enc = Encodings.newDefaultEncoding();
        List<Integer> encoded = Arrays.asList(-72, -101, -108, -108, -111);
        
        String result = TikTokensUtil.decode(enc, encoded);

        Assertions.assertNotEquals("Hello", result);
    }

    @Test
    public void testDecodeWithIntegersOutOfRangeInEncodedList() {
        Encoding enc = Encodings.newDefaultEncoding();
        List<Integer> encoded = Arrays.asList(70000, 101, 108, 108, 111);
        
        Assertions.assertThrows(IllegalArgumentException.class, () -> TikTokensUtil.decode(enc, encoded));
    }

    @Test
    public void testDecodeWithLargeEncodedList() {
        Encoding enc = Encodings.newDefaultEncoding();
        List<Integer> encoded = new ArrayList<>(Collections.nCopies(10000, 72));
        
        String result = TikTokensUtil.decode(enc, encoded);

        Assertions.assertEquals(10000, result.length());
    }
}
